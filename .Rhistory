msg = { sprintf("Preparing to save %s[%s] to %s: \nContinue? ", env_ref, paste(i, collapse = ", "), tmp.file) }
if (askYesNo(msg, prompt = "Y/N/C")) {
save(list = i, envir = env, file = tmp.file, compress = "bzip2", precheck = safe)
} else { message("Canceling operation ...") }
} else { save(list = i , envir = env, file = tmp.file, compress = "bzip2") }
}
#
do.copy_obj <- function(..., from.env = .GlobalEnv, to.env, keep.orig = TRUE, chatty = FALSE, .debug = FALSE) {
#' Replace, [C]opy, or [M]ove objects
#'
#' @description
#' \code{do.copy_obj} Facilitates the renaming, copying, and moving of objects within and across environments.
#' If \code{to.env} is \code{NULL}, the execution will simply replace the object under a new name.
#' If \code{to.env} has multiple values, the copy or move operations will populate each environment.
#'
#' @param ... (\code{\link[rlang]{dots_list}}) String(s) giving the names of the object(s) to be moved: may include environment prefix (e.g., \code{FROM_ENV$from.name}).  Elements given as a key-value pair will have the names of keys become the destination object names; otherwise, the value is (parsed and ) used as the destination name.  For example, \code{... = list(a = this, that, TO_ENV$the_other = other)} results in three destination objects named \code{a}, \code{that}, and \code{the_other} with \code{the_other} created in environment \code{TO_ENV}.
#' @param from.env (string| \code{.GlobalEnv}): The default source environment of the object(s) to be moved/copied
#' @param to.env (string| \code{.GlobalEnv}): The default target environment of the target object
#' @param keep.orig (logical | \code{TRUE}): When \code{FALSE}, the original is removed via \code{\link[base]{rm}}
#' @param chatty (logical | \code{FALSE}): Verbosity flag
#'
#' @export
# :: Helper function to create the environment and object strings
sub_fn = function(i, dflt){
if (rlang::has_length(i, 1)){
expand.grid(dflt, i, stringsAsFactors = FALSE)
} else {
list(paste(i[1:(length(i) - 1L)], collapse = "$"), i[length(i)])
}
}
from.env = as.character(rlang::enexpr(from.env));
to.env = if (missing(to.env)){
from.env
} else {
.out <- rlang::enexpr(to.env) %>% as.character();
if (length(.out) > 1){ .out[-1] } else { .out }
}
.args = rlang::list2(!!!purrr::map(rlang::exprs(...), as.character)) %>%
purrr::map(~{
.str = if(class(.x) %in% c("symbol", "name")){ as.character(.x) } else { .x }
.str %>% stringi::stri_split_regex(pattern = c('[,;| ]'), simplify = TRUE) %>% trimws() %>% c()
}) %>%
unlist();
# :: Source object strings
.source = suppressWarnings({
if (length(.args) == 1){
stringi::stri_split_fixed(.args, "[$]", simplify = TRUE, omit_empty = FALSE) %>% sub_fn(from.env)
} else { purrr::map_dfr(.args, ~{
stringi::stri_split_fixed(.x, "[$]", simplify = TRUE, omit_empty = FALSE) %>% sub_fn(from.env) })
}
})
# :: Target object strings
.target = suppressWarnings({
if (length(.args) == 1){
stringi::stri_split_fixed(names(.args), "$", simplify = TRUE, omit_empty = FALSE) %>% sub_fn(to.env)
} else {
purrr::map(names(.args), ~{
stringi::stri_split_fixed(.x, "$", simplify = TRUE, omit_empty = FALSE) %>% sub_fn(to.env)
}) %>% purrr::reduce(rbind)
}
})
# :: The plan of action along with the inputs
.xfer_map = data.table::as.data.table(cbind(.source, .target));
data.table::setnames(.xfer_map, c("FR_" %s+% c("ENV", "OBJ"), "TO_" %s+% c("ENV", "OBJ")));
.xfer_map[
, TO_OBJ := ifelse(TO_OBJ == "", FR_OBJ, TO_OBJ)
][
, `:=`(
ACTION = purrr::pmap_chr(.SD, function(...){
sprintf("%s$%s <- %s$%s", ...elt(3), ...elt(4), ...elt(1), ...elt(2))
})
, VALID = purrr::pmap(.SD, function(...){
c(env_check = (...elt(2) %in% { parse(text = ...elt(1)) %>% eval(envir = globalenv()) %>% ls() })
, obj_check = !is.null(parse(text = ...elt(3)) %>% eval(envir = globalenv()))) %>% t()
})
)
];
if (.debug){
cat("Arguments\n");
print(unlist(.args));
cat("Unnamed targets\n");
print(.args[which(names(.args) == "")]);
cat("Transfer map\n");
print(.xfer_map);
}
# :: ACTION!
.xfer_map[!sapply(VALID, all), ACTION] %>% purrr::walk(~message("Skipping invalid operation: " %s+% .x));
.xfer_map[sapply(VALID, all), ACTION] %>% purrr::walk(~{
if (chatty){ message("Executing " %s+% .x, appendLF = FALSE) }
parse(text = .x) %>% eval(envir = globalenv());
});
# :: If a 'move' action, remove the source objects from the corresponding environments
if (!keep.orig){ .xfer_map[
sapply(VALID, all)
, rm(list = unique(FR_OBJ), envir = eval(parse(text = FR_ENV), envir = globalenv()))
, by = FR_ENV
]}
return(invisible(0));
}
BLAH <- new.env()
BLEH <- new.env()
set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
sapply(dir("R", full.names = TRUE), source)
library(purrr);
library(stringi);
library(parallelly);
library(future);
library(foreach);
library(data.table)
sapply(dir("R", full.names = TRUE), source)
library(purrr);
library(stringi);
library(parallelly);
library(future);
library(foreach);
library(data.table)
# ~ do.copy_obj() ====
BLAH <- new.env()
BLEH <- new.env()
set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
do.copy_obj(A, keep.orig = TRUE, .debug = !TRUE);
ls(pattern = .pattern)
# [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J"
do.copy_obj(B, C, D, keep.orig = TRUE, .debug = !TRUE);
ls(pattern = .pattern)
# [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J"
do.copy_obj(B, C, D, to.env = BLAH, keep.orig = TRUE, .debug = !TRUE);
ls(BLAH, pattern = .pattern)
# [1] "B" "C" "D"
do.copy_obj(B, C, D, from.env = BLAH, to.env = BLEH, keep.orig = TRUE, .debug = !TRUE);
ls(BLEH, pattern = .pattern)
# [1] "B" "C" "D" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
do.copy_obj(E, `F`, G, to.env = BLEH, keep.orig = TRUE, .debug = !TRUE);
purrr::map(purrr::set_names(c("BLAH", "BLEH")), ~ls(pattern = .pattern, envir = eval(as.symbol(.x))));
# $BLAH
# [1] "B" "C" "D"
#
# $BLEH
# [1] "B" "C" "D" "E" "F" "G" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
do.copy_obj(A, B, C, D, E, `F`, G, to.env = c(BLEH, BLAH), keep.orig = TRUE, .debug = !TRUE);
map(purrr::set_names(c("BLAH", "BLEH")), ~ls(pattern = .pattern, envir = eval(as.symbol(.x))));
# $BLAH
# [1] "A" "B" "C" "D" "E" "F" "G"
#
# $BLEH
# [1] "A" "B" "C" "D" "E" "F" "G" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
do.copy_obj(!!!LETTERS[1:7], to.env = c(BLEH, BLAH), keep.orig = FALSE, .debug = !TRUE);
map(purrr::set_names(c("BLAH", "BLEH", ".GlobalEnv")), ~ls(pattern = .pattern, envir = eval(as.symbol(.x))));
# $BLAH
# [1] "A" "B" "C" "D" "E" "F" "G"
#
# $BLEH
# [1] "A" "B" "C" "D" "E" "F" "G" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
#
# $.GlobalEnv
# [1] "H" "I" "J"
do.copy_obj(`BLAH$alpha` = H, `BLAH$beta` = I, `BLEH$gamma` = J, keep.orig = TRUE, .debug = !TRUE);
.pattern <- "^[A-Z]$|(alpha|beta|gamma)"
map(purrr::set_names(c("BLAH", "BLEH", ".GlobalEnv")), ~ls(pattern = paste0(.pattern, "|(^a-z)"), envir = eval(as.symbol(.x))));
# BLAH
# [1] "A" "alpha" "B" "beta" "C" "D" "E" "F" "G"
#
# $BLEH
# [1] "A" "B" "C" "D" "E" "F" "G" "gamma" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
#
# $.GlobalEnv
# [1] "H" "I" "J"
# ~ do.save.image():: Only check the prompt to ensure the expected objects and environment return ====
# debug(do.save_image)
do.save_image();
#
do.save_image <- function(..., safe = TRUE, env = .GlobalEnv, save.dir = getwd(), file.name = "", use.prefix = TRUE, prepare = NULL){
#' Manual Export of Workspace Objects
#'
#' The default value for \code{i} exports the entire workspace.  Unless `file` is \code{NULL}, when \code{i} is a vector of names or delimited string of names, the file name becomes 'multiObs'; otherwise, the file name is set to the value of \code{i}. When {i} contains 'all' or '*', regardless of the full content of \code{i}, the entire workspace is exported.
#'
#' @param ... (vector or list) Names of objects to save given as strings or symbols. Strings may be delimited (\code{c(',', ';', '|', ' ')})
#' @param safe	(logical | \code{TRUE}) Should the pending action be confirmed at the prompt?
#' @param env	The environment to search for items
#' @param save.dir (string | \code{getwd()}) The directory to save to (not the file name).  Use \code{TRUE} to interactively choose a save directory.
#' @param file.name	(string | "") The name of the file to save, or, when \code{NULL}, the value of \code{i} if atomic or a predefined name when \code{i} is a vector
#' @param use.prefix (logical | \code{TRUE}) When \code{TRUE} (the default), the file name is prefixed with the value of \code{env}
#' @param prepare	(language | \code{NULL}) A quoted expression that executes before the save action takes place.
#'
#' @return A `.rdata` file, the filename of which being suffixed with a timestamp formatted as "yyyy.mm.dd.hhmmss"
#'
#' @family Environment Processing
#' @export
# :: Preliminary checks on supplied parameters
obj.nms <- NULL;
env_ref <- as.character(rlang::enexpr(env));
if ("character" %in% class(env)){
env <- if (env %in% search()) { env <- as.environment(env) } else { eval(as.symbol(env)) }
}
if (!is.null(prepare)) { eval(prepare, envir = env) }
if (...length() == 0){ obj.nms <- ls(envir = env) }
i =  purrr::map(as.character(rlang::enexprs(...)), ~stringi::stri_split_regex(.x, pattern = "[,;| ]", simplify = TRUE, omit_empty = TRUE)) |> unlist()
if (rlang::is_empty(i)){ i <- "all" }
if (save.dir == TRUE){ save.dir <- tcltk::tk_choose.dir(default = getwd(), caption = "Choose the 'save' directory:") }
filecheck = is.null(file.name) | (stringi::stri_length(trimws(file.name)) == 0)
# :: Environment reference from string
namescheck = { c(
all = { any(i %in% c("*", "all")) }
, single.obj = { (length(i) == 1) & !any(i %in% c("*", "all")) & (stringi::stri_length(i) > 0)}
, multi.as.vector = { (length(i) > 1) & !any(i %in% c("*", "all")) }
, multi.as.string = { any((i %like% "[,;| ]") & !any(i %in% c("*", "all"))) }
) %>%
purrr::keep(~.x) %>% names() %>% .[1]
}
# :: Set the file name based on the values supplied to argument `i`
switch(
namescheck
, "all" 						= { file.name <- ifelse(filecheck, "all", file.name); i <- ls(envir = env, all.names = TRUE) }
, "multi.as.string" = { file.name <- ifelse(filecheck, "multiObs", file.name);
i <- stringi::stri_split_regex(i, "[,;| ]", omit_empty = TRUE, simplify = TRUE) %>% c();
}
, "multi.as.vector" = { file.name <- ifelse(filecheck, "multiObs", file.name) }
, 										{ file.name <- ifelse(filecheck, i, file.name) }
);
# :: Write the binary file to disk
tstamp = format(Sys.time(), "%Y.%m.%d.%H%M%S");
tmp.file = sprintf("%s/%s%s_%s.rdata", save.dir, if (use.prefix){ ifelse(env %like% "Global", "", paste0(env, "$")) } else { "" }, file.name, tstamp);
if (safe) {
msg = { sprintf("Preparing to save %s[%s] to %s: \nContinue? ", env_ref, paste(i, collapse = ", "), tmp.file) }
if (askYesNo(msg, prompt = "Y/N/C")) {
save(list = i, envir = env, file = tmp.file, compress = "bzip2", precheck = safe)
} else { message("Canceling operation ...") }
} else { save(list = i , envir = env, file = tmp.file, compress = "bzip2") }
}
# ~ do.save.image():: Only check the prompt to ensure the expected objects and environment return ====
# debug(do.save_image)
do.save_image();
# ~ do.save.image():: Only check the prompt to ensure the expected objects and environment return ====
# debug(do.save_image)
debug(do.save_image)
do.save_image();
#
do.save_image <- function(..., safe = TRUE, env = .GlobalEnv, save.dir = getwd(), file.name = "", use.prefix = TRUE, prepare = NULL){
#' Manual Export of Workspace Objects
#'
#' The default value for \code{i} exports the entire workspace.  Unless `file` is \code{NULL}, when \code{i} is a vector of names or delimited string of names, the file name becomes 'multiObs'; otherwise, the file name is set to the value of \code{i}. When {i} contains 'all' or '*', regardless of the full content of \code{i}, the entire workspace is exported.
#'
#' @param ... (vector or list) Names of objects to save given as strings or symbols. Strings may be delimited (\code{c(',', ';', '|', ' ')})
#' @param safe	(logical | \code{TRUE}) Should the pending action be confirmed at the prompt?
#' @param env	The environment to search for items
#' @param save.dir (string | \code{getwd()}) The directory to save to (not the file name).  Use \code{TRUE} to interactively choose a save directory.
#' @param file.name	(string | "") The name of the file to save, or, when \code{NULL}, the value of \code{i} if atomic or a predefined name when \code{i} is a vector
#' @param use.prefix (logical | \code{TRUE}) When \code{TRUE} (the default), the file name is prefixed with the value of \code{env}
#' @param prepare	(language | \code{NULL}) A quoted expression that executes before the save action takes place.
#'
#' @return A `.rdata` file, the filename of which being suffixed with a timestamp formatted as "yyyy.mm.dd.hhmmss"
#'
#' @family Environment Processing
#' @export
# :: Preliminary checks on supplied parameters
obj.nms <- NULL;
env_ref <- as.character(rlang::enexpr(env));
if ("character" %in% class(env)){
env <- if (env %in% search()) { env <- as.environment(env) } else { eval(as.symbol(env)) }
}
if (!is.null(prepare)) { eval(prepare, envir = env) }
if (...length() == 0){ obj.nms <- ls(envir = env) }
i =  purrr::map(as.character(rlang::enexprs(...)), ~stringi::stri_split_regex(.x, pattern = "[,;| ]", simplify = TRUE, omit_empty = TRUE)) |> unlist()
if (rlang::is_empty(i)){ i <- "all" }
if (save.dir == TRUE){ save.dir <- tcltk::tk_choose.dir(default = getwd(), caption = "Choose the 'save' directory:") }
filecheck = is.null(file.name) | (stringi::stri_length(trimws(file.name)) == 0)
# :: Environment reference from string
namescheck = { c(
all = { any(i %in% c("*", "all")) }
, single.obj = { (length(i) == 1) & !any(i %in% c("*", "all")) & (stringi::stri_length(i) > 0)}
, multi.as.vector = { (length(i) > 1) & !any(i %in% c("*", "all")) }
, multi.as.string = { any((i %like% "[,;| ]") & !any(i %in% c("*", "all"))) }
) %>%
purrr::keep(~.x) %>% names() %>% .[1]
}
# :: Set the file name based on the values supplied to argument `i`
switch(
namescheck
, "all" 						= { file.name <- ifelse(filecheck, "all", file.name); i <- ls(envir = env, all.names = TRUE) }
, "multi.as.string" = { file.name <- ifelse(filecheck, "multiObs", file.name);
i <- stringi::stri_split_regex(i, "[,;| ]", omit_empty = TRUE, simplify = TRUE) %>% c();
}
, "multi.as.vector" = { file.name <- ifelse(filecheck, "multiObs", file.name) }
, 										{ file.name <- ifelse(filecheck, i, file.name) }
);
# :: Write the binary file to disk
tstamp = format(Sys.time(), "%Y.%m.%d.%H%M%S");
tmp.file = sprintf("%s/%s%s_%s.rdata", save.dir, if (use.prefix){ ifelse(env %like% "Global", "", paste0(env_ref, "$")) } else { "" }, file.name, tstamp);
if (safe) {
msg = { sprintf("Preparing to save %s[%s] to %s: \nContinue? ", env_ref, paste(i, collapse = ", "), tmp.file) }
if (askYesNo(msg, prompt = "Y/N/C")) {
save(list = i, envir = env, file = tmp.file, compress = "bzip2", precheck = safe)
} else { message("Canceling operation ...") }
} else { save(list = i , envir = env, file = tmp.file, compress = "bzip2") }
}
do.save_image();
#
do.save_image <- function(..., safe = TRUE, env = .GlobalEnv, save.dir = getwd(), file.name = "", use.prefix = TRUE, prepare = NULL){
#' Manual Export of Workspace Objects
#'
#' The default value for \code{i} exports the entire workspace.  Unless `file` is \code{NULL}, when \code{i} is a vector of names or delimited string of names, the file name becomes 'multiObs'; otherwise, the file name is set to the value of \code{i}. When {i} contains 'all' or '*', regardless of the full content of \code{i}, the entire workspace is exported.
#'
#' @param ... (vector or list) Names of objects to save given as strings or symbols. Strings may be delimited (\code{c(',', ';', '|', ' ')})
#' @param safe	(logical | \code{TRUE}) Should the pending action be confirmed at the prompt?
#' @param env	The environment to search for items
#' @param save.dir (string | \code{getwd()}) The directory to save to (not the file name).  Use \code{TRUE} to interactively choose a save directory.
#' @param file.name	(string | "") The name of the file to save, or, when \code{NULL}, the value of \code{i} if atomic or a predefined name when \code{i} is a vector
#' @param use.prefix (logical | \code{TRUE}) When \code{TRUE} (the default), the file name is prefixed with the value of \code{env}
#' @param prepare	(language | \code{NULL}) A quoted expression that executes before the save action takes place.
#'
#' @return A `.rdata` file, the filename of which being suffixed with a timestamp formatted as "yyyy.mm.dd.hhmmss"
#'
#' @family Environment Processing
#' @export
# :: Preliminary checks on supplied parameters
obj.nms <- NULL;
env_ref <- as.character(rlang::enexpr(env));
if ("character" %in% class(env)){
env <- if (env %in% search()) { env <- as.environment(env) } else { eval(as.symbol(env)) }
}
if (!is.null(prepare)) { eval(prepare, envir = env) }
if (...length() == 0){ obj.nms <- ls(envir = env) }
i =  purrr::map(as.character(rlang::enexprs(...)), ~stringi::stri_split_regex(.x, pattern = "[,;| ]", simplify = TRUE, omit_empty = TRUE)) |> unlist()
if (rlang::is_empty(i)){ i <- "all" }
if (save.dir == TRUE){ save.dir <- tcltk::tk_choose.dir(default = getwd(), caption = "Choose the 'save' directory:") }
filecheck = is.null(file.name) | (stringi::stri_length(trimws(file.name)) == 0)
# :: Environment reference from string
namescheck = { c(
all = { any(i %in% c("*", "all")) }
, single.obj = { (length(i) == 1) & !any(i %in% c("*", "all")) & (stringi::stri_length(i) > 0)}
, multi.as.vector = { (length(i) > 1) & !any(i %in% c("*", "all")) }
, multi.as.string = { any((i %like% "[,;| ]") & !any(i %in% c("*", "all"))) }
) %>%
purrr::keep(~.x) %>% names() %>% .[1]
}
# :: Set the file name based on the values supplied to argument `i`
switch(
namescheck
, "all" 						= { file.name <- ifelse(filecheck, "all", file.name); i <- ls(envir = env, all.names = TRUE) }
, "multi.as.string" = { file.name <- ifelse(filecheck, "multiObs", file.name);
i <- stringi::stri_split_regex(i, "[,;| ]", omit_empty = TRUE, simplify = TRUE) %>% c();
}
, "multi.as.vector" = { file.name <- ifelse(filecheck, "multiObs", file.name) }
, 										{ file.name <- ifelse(filecheck, i, file.name) }
);
# :: Write the binary file to disk
tstamp = format(Sys.time(), "%Y.%m.%d.%H%M%S");
tmp.file = sprintf("%s/%s%s_%s.rdata", save.dir, if (use.prefix){ ifelse(env_ref %like% "Global", "", paste0(env_ref, "$")) } else { "" }, file.name, tstamp);
if (safe) {
msg = { sprintf("Preparing to save %s[%s] to %s: \nContinue? ", env_ref, paste(i, collapse = ", "), tmp.file) }
if (askYesNo(msg, prompt = "Y/N/C")) {
save(list = i, envir = env, file = tmp.file, compress = "bzip2", precheck = safe)
} else { message("Canceling operation ...") }
} else { save(list = i , envir = env, file = tmp.file, compress = "bzip2") }
}
do.save_image();
do.save_image(!!!ls())
do.save_image(!!!LETTERS[1:6], env = BLEH)
# pkgdown ----
pkgdown::build_site()
library(book.of.workflow)
library(book.of.workflow)
library(book.of.workflow)
sapply(dir("R", full.names = TRUE), source)
library(book.of.workflow)
library(book.of.workflow)
#
# ~ do.copy_obj() ====
BLAH <- new.env()
BLEH <- new.env()
set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
do.copy_obj(A, keep.orig = TRUE, .debug = !TRUE);
ls(pattern = .pattern)
# [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J"
do.copy_obj(B, C, D, keep.orig = TRUE, .debug = !TRUE);
ls(pattern = .pattern)
# [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J"
do.copy_obj(B, C, D, to.env = BLAH, keep.orig = TRUE, .debug = !TRUE);
ls(BLAH, pattern = .pattern)
# [1] "B" "C" "D"
do.copy_obj(B, C, D, from.env = BLAH, to.env = BLEH, keep.orig = TRUE, .debug = !TRUE);
ls(BLEH, pattern = .pattern)
# [1] "B" "C" "D" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
do.copy_obj(E, `F`, G, to.env = BLEH, keep.orig = TRUE, .debug = !TRUE);
purrr::map(purrr::set_names(c("BLAH", "BLEH")), ~ls(pattern = .pattern, envir = eval(as.symbol(.x))));
# $BLAH
# [1] "B" "C" "D"
#
# $BLEH
# [1] "B" "C" "D" "E" "F" "G" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
do.copy_obj(A, B, C, D, E, `F`, G, to.env = c(BLEH, BLAH), keep.orig = TRUE, .debug = !TRUE);
map(purrr::set_names(c("BLAH", "BLEH")), ~ls(pattern = .pattern, envir = eval(as.symbol(.x))));
# $BLAH
# [1] "A" "B" "C" "D" "E" "F" "G"
#
# $BLEH
# [1] "A" "B" "C" "D" "E" "F" "G" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
do.copy_obj(!!!LETTERS[1:7], to.env = c(BLEH, BLAH), keep.orig = FALSE, .debug = !TRUE);
map(purrr::set_names(c("BLAH", "BLEH", ".GlobalEnv")), ~ls(pattern = .pattern, envir = eval(as.symbol(.x))));
# $BLAH
# [1] "A" "B" "C" "D" "E" "F" "G"
#
# $BLEH
# [1] "A" "B" "C" "D" "E" "F" "G" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
#
# $.GlobalEnv
# [1] "H" "I" "J"
do.copy_obj(`BLAH$alpha` = H, `BLAH$beta` = I, `BLEH$gamma` = J, keep.orig = TRUE, .debug = !TRUE);
.pattern <- "^[A-Z]$|(alpha|beta|gamma)"
map(purrr::set_names(c("BLAH", "BLEH", ".GlobalEnv")), ~ls(pattern = paste0(.pattern, "|(^a-z)"), envir = eval(as.symbol(.x))));
# BLAH
# [1] "A" "alpha" "B" "beta" "C" "D" "E" "F" "G"
#
# $BLEH
# [1] "A" "B" "C" "D" "E" "F" "G" "gamma" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
#
# $.GlobalEnv
# [1] "H" "I" "J"
library(purrr);
#
# ~ do.copy_obj() ====
BLAH <- new.env()
BLEH <- new.env()
set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
do.copy_obj(A, keep.orig = TRUE, .debug = !TRUE);
ls(pattern = .pattern)
# [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J"
do.copy_obj(B, C, D, keep.orig = TRUE, .debug = !TRUE);
ls(pattern = .pattern)
# [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J"
do.copy_obj(B, C, D, to.env = BLAH, keep.orig = TRUE, .debug = !TRUE);
ls(BLAH, pattern = .pattern)
# [1] "B" "C" "D"
do.copy_obj(B, C, D, from.env = BLAH, to.env = BLEH, keep.orig = TRUE, .debug = !TRUE);
ls(BLEH, pattern = .pattern)
# [1] "B" "C" "D" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
do.copy_obj(E, `F`, G, to.env = BLEH, keep.orig = TRUE, .debug = !TRUE);
purrr::map(purrr::set_names(c("BLAH", "BLEH")), ~ls(pattern = .pattern, envir = eval(as.symbol(.x))));
# $BLAH
# [1] "B" "C" "D"
#
# $BLEH
# [1] "B" "C" "D" "E" "F" "G" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
do.copy_obj(A, B, C, D, E, `F`, G, to.env = c(BLEH, BLAH), keep.orig = TRUE, .debug = !TRUE);
map(purrr::set_names(c("BLAH", "BLEH")), ~ls(pattern = .pattern, envir = eval(as.symbol(.x))));
# $BLAH
# [1] "A" "B" "C" "D" "E" "F" "G"
#
# $BLEH
# [1] "A" "B" "C" "D" "E" "F" "G" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
do.copy_obj(!!!LETTERS[1:7], to.env = c(BLEH, BLAH), keep.orig = FALSE, .debug = !TRUE);
map(purrr::set_names(c("BLAH", "BLEH", ".GlobalEnv")), ~ls(pattern = .pattern, envir = eval(as.symbol(.x))));
# $BLAH
# [1] "A" "B" "C" "D" "E" "F" "G"
#
# $BLEH
# [1] "A" "B" "C" "D" "E" "F" "G" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
#
# $.GlobalEnv
# [1] "H" "I" "J"
do.copy_obj(`BLAH$alpha` = H, `BLAH$beta` = I, `BLEH$gamma` = J, keep.orig = TRUE, .debug = !TRUE);
.pattern <- "^[A-Z]$|(alpha|beta|gamma)"
map(purrr::set_names(c("BLAH", "BLEH", ".GlobalEnv")), ~ls(pattern = paste0(.pattern, "|(^a-z)"), envir = eval(as.symbol(.x))));
# BLAH
# [1] "A" "alpha" "B" "beta" "C" "D" "E" "F" "G"
#
# $BLEH
# [1] "A" "B" "C" "D" "E" "F" "G" "gamma" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S" "T"
#
# $.GlobalEnv
# [1] "H" "I" "J"
# ~ do.save.image():: Only check the prompt to ensure the expected objects and environment return ====
# debug(do.save_image)
do.save_image();
do.save_image(!!!LETTERS[1:6], env = BLEH)
# pkgdown ----
pkgdown::build_site()
library(book.of.workflow)
library(book.of.workflow)
library(DBI)
db_conn <- DBI::dbConnect(odbc::odbc(), dsn = "GW2DB_Agent",
uid = keyring::key_list(keyring = "gw2_api", service = "SQLServer")[,
"username"], pwd = keyring::key_get(keyring = "gw2_api",
service = "SQLServer", username = "imperial_agent"))
library(book.of.workflow)
library(book.of.workflow)
rlang::expr_print(this is an expression)
rlang::expr_print(`this is an expression`)
rlang::expr_text(expr = `This is a test`)
rlang::expr_text(expr = rlang::expr(`This is a test`))
rlang::expr_text(expr = rlang::expr(This is a test))
library(book.of.workflow)
library(book.of.workflow)
library(book.of.workflow)
library(book.of.workflow)
use_mit_license()
?use_mit_license
??use_mit_license
usethis::use_proprietary_license()
packageDescription()#usethis::use_proprietary_license()
packageDescription("book.of.workflow")#usethis::use_proprietary_license()
usethis::use_proprietary_license(packageDescription("book.of.workflow")$Author)
library(book.of.workflow)
pkgdown::build_site()
