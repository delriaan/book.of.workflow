library(purrr);
library(stringi);
library(parallelly);
library(future);
library(foreach);
library(data.table);
sapply(dir("pkg/R", full.names = TRUE), source)
make_test_objs <- rlang::expr({
BLAH <- new.env()
BLEH <- new.env()
rlang::set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
rlang::set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
})
make_test_objs |> eval()
environment() %must.have% A
`%must.have%`(.GlobalEnv) # NULL
copy_obj(A, keep.orig = TRUE);
check.env(.GlobalEnv)
debug(check.env)
environment() %must.have% A
`%must.have%`(.GlobalEnv) # NULL
copy_obj(A, keep.orig = TRUE);
check.env(.GlobalEnv)
attr(.x, "must.have")
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(..., .named = TRUE) |> purrr::imap(check_env_arg);
purrr::iwalk(envs, ~{
.names <- attr(.x, "must.have");
if (rlang::is_empty(.names)){
cat("No required values set: exiting ..;", sep = "\n");
return("N/A")
}
.test <- rlang::env_has(.x, .names);
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
cat(glue::glue("Checking `{.y}`: {ifelse(all(.test), .pass, .fail)}"), sep = "\n")
})
}
environment() %must.have% A
`%must.have%`(.GlobalEnv) # NULL
copy_obj(A, keep.orig = TRUE);
check.env(.GlobalEnv)
environment() %must.have% A
`%must.have%`(.GlobalEnv) # NULL
copy_obj(A, keep.orig = TRUE);
check.env(.GlobalEnv)
envs <- rlang::enquos(..., .named = TRUE) |> purrr::imap(\(x, y) check_env_arg(x, y));
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(..., .named = TRUE) |> purrr::imap(\(x, y) check_env_arg(x, y));
purrr::iwalk(envs, ~{
.names <- attr(.x, "must.have");
if (rlang::is_empty(.names)){
cat("No required values set: exiting ..;", sep = "\n");
return("N/A")
}
.test <- rlang::env_has(.x, .names);
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
cat(glue::glue("Checking `{.y}`: {ifelse(all(.test), .pass, .fail)}"), sep = "\n")
})
}
environment() %must.have% A
`%must.have%`(.GlobalEnv) # NULL
copy_obj(A, keep.orig = TRUE);
check.env(.GlobalEnv)
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(...) |> purrr::map(\(x, y) check_env_arg(x, rlang::as_label(rlang::quo_get_expr(x))));
purrr::iwalk(envs, ~{
.names <- attr(.x, "must.have");
if (rlang::is_empty(.names)){
cat("No required values set: exiting ..;", sep = "\n");
return("N/A")
}
.test <- rlang::env_has(.x, .names);
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
cat(glue::glue("Checking `{.y}`: {ifelse(all(.test), .pass, .fail)}"), sep = "\n")
})
}
environment() %must.have% A
`%must.have%`(.GlobalEnv) # NULL
copy_obj(A, keep.orig = TRUE);
check.env(.GlobalEnv)
.GlobalEnv %must.have% A
`%must.have%`(.GlobalEnv) # NULL
copy_obj(A, keep.orig = TRUE);
check.env(.GlobalEnv)
.GlobalEnv %must.have% "A"
`%must.have%`(.GlobalEnv) # NULL
.GlobalEnv %must.have% "A"
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked.  Use the \code{\link[rlang]{!!}} operator when passing a vector or list.
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env, env_nm = rlang::as_label(rlang::enexpr(env)));
x <- rlang::enexprs(x) |> purrr::compact();
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map(x, as.character) |> unlist()
} else {
attr(env, "must.have") <- purrr::map(x, as.character) |> unlist() |> c(attr(env, "must.have")) |> unique()
}
}
}
.GlobalEnv %must.have% "A"
.GlobalEnv %must.have% "A"
`%must.have%`(.GlobalEnv) # NULL
copy_obj(A, keep.orig = TRUE);
check.env(.GlobalEnv)
.GlobalEnv %must.have% !!c("B", "C", "D", `%must.have%`(.GlobalEnv))
`%must.have%`(.GlobalEnv) 	# NULL
copy_obj(B, C, D, keep.orig = TRUE)
check.env(.GlobalEnv)
unit_tests[3]
unit_tests <- list()
unit_tests$copy_obj <- "unit_tests/copy_obj_test.R"
unit_tests$snippets <-"unit_tests/snippets_test.R"
unit_tests$must_have <-"unit_tests/must_have_test.R"
unit_tests$load_unloaded <-"unit_tests/load_unloaded_test.R"
# Unit Tests: copy_obj(), make.snippet(), read.snippet(), %must.have% ====
(\(x, y = names(x)){ message(y); source(x) })(unit_tests[3]);
unit_tests[3]
# Unit Tests: copy_obj(), make.snippet(), read.snippet(), %must.have% ====
(\(x, y = names(x)){ message(y); source(x[[1]]) })(unit_tests[3]);
# </snippet>
check.env(BLAH, BLEH)
# ~ save.image():: Only check the prompt to ensure the expected objects and environment return ====
# debug(save_image)
save_image();
save_image(); "N"
save_image(!!!ls());
save_image(!!!LETTERS[1:6], env = BLEH);
save_image(!!!LETTERS[1:6], env = BLEH, file.name = "all");
sapply(dir("pkg/R", full.names = TRUE), source)
make_test_objs <- rlang::expr({
BLAH <- new.env()
BLEH <- new.env()
rlang::set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
rlang::set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
})
make_test_objs |> eval()
unit_tests <- list()
unit_tests$copy_obj <- "unit_tests/copy_obj_test.R"
unit_tests$must_have <-"unit_tests/must_have_test.R"
unit_tests$snippets <-"unit_tests/snippets_test.R"
unit_tests$load_unloaded <-"unit_tests/load_unloaded_test.R"
# ~ load_unloaded() :: Run from fresh session to ensure libraries are not loaded ----
(\(x, y = names(x)){ message(y); source(x[[1]]) })(unit_tests$load_unloaded);
sapply(dir("pkg/R", full.names = TRUE), source)
make_test_objs <- rlang::expr({
BLAH <- new.env()
BLEH <- new.env()
rlang::set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
rlang::set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
})
make_test_objs |> eval()
unit_tests <- list()
unit_tests$copy_obj <- "unit_tests/copy_obj_test.R"
unit_tests$must_have <-"unit_tests/must_have_test.R"
unit_tests$snippets <-"unit_tests/snippets_test.R"
unit_tests$load_unloaded <-"unit_tests/load_unloaded_test.R"
# ~ load_unloaded() :: Run from fresh session to ensure libraries are not loaded ----
(\(x, y = names(x)){ message(y); source(x[[1]]) })(unit_tests$load_unloaded);
# library(magick)
# library(jsonlite)
# library(sodium)
# magick::image_read("book-305126_1280.png") %>% serialize(connection = NULL) %>% base64enc::base64encode() %>% writeClipboard()
sapply(dir("pkg/R", full.names = TRUE), source)
make_test_objs <- rlang::expr({
BLAH <- new.env()
BLEH <- new.env()
rlang::set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
rlang::set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
})
make_test_objs |> eval()
unit_tests <- list()
unit_tests$copy_obj <- "unit_tests/copy_obj_test.R"
unit_tests$must_have <-"unit_tests/must_have_test.R"
unit_tests$snippets <-"unit_tests/snippets_test.R"
unit_tests$load_unloaded <-"unit_tests/load_unloaded_test.R"
# ~ load_unloaded() :: Run from fresh session to ensure libraries are not loaded ----
(\(x, y = names(x)){ message(y); source(x[[1]]) })(unit_tests$load_unloaded);
"future_imap" %in% ls(as.environment("package:furrr")) == FALSE|> print()
("future_imap" %in% ls(as.environment("package:furrr")) == FALSE)
# library(magick)
# library(jsonlite)
# library(sodium)
# magick::image_read("book-305126_1280.png") %>% serialize(connection = NULL) %>% base64enc::base64encode() %>% writeClipboard()
sapply(dir("pkg/R", full.names = TRUE), source)
make_test_objs <- rlang::expr({
BLAH <- new.env()
BLEH <- new.env()
rlang::set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
rlang::set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
})
make_test_objs |> eval()
unit_tests <- list()
unit_tests$copy_obj <- "unit_tests/copy_obj_test.R"
unit_tests$must_have <-"unit_tests/must_have_test.R"
unit_tests$snippets <-"unit_tests/snippets_test.R"
unit_tests$load_unloaded <-"unit_tests/load_unloaded_test.R"
# ~ load_unloaded() :: Run from fresh session to ensure libraries are not loaded ----
(\(x, y = names(x)){ message(y); source(x[[1]]) })(unit_tests$load_unloaded);
#
#
# %+=%, %-=% ----
BLAH %+=% list(Z = 10)
source("D:/Imperial Git Repos/book.of.workflow/pkg/R/2_environment_integrity.R")
#
#
# %+=%, %-=% ----
BLAH %+=% list(Z = 10)
rlang::env_has(BLAH, "Z") # TRUE
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3))
rlang::env_has(BLAH, c("W", "Y")) # TRUE TRUE
rm(W, Y, Z, envir = BLAH)
BLAH %must.have% !!c("W", "Y", "Z")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`: PASS
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(...) |>
rlang::set_names(purrr::map_chr(\(x) rlang::as_label(rlang::quo_get_expr(x)))) |>
purrr::map(check_env_arg);
purrr::iwalk(envs, ~{
.names <- attr(.x, "must.have");
if (rlang::is_empty(.names)){
cat("No required values set: exiting ..;", sep = "\n");
return("N/A")
}
.test <- rlang::env_has(.x, .names);
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
cat(glue::glue("Checking `{.y}`: {ifelse(all(.test), .pass, .fail)}"), sep = "\n")
})
}
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`: PASS
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(...) %>%
rlang::set_names(purrr::map_chr(., \(x) rlang::as_label(rlang::quo_get_expr(x)))) |>
purrr::map(check_env_arg);
purrr::iwalk(envs, ~{
.names <- attr(.x, "must.have");
if (rlang::is_empty(.names)){
cat("No required values set: exiting ..;", sep = "\n");
return("N/A")
}
.test <- rlang::env_has(.x, .names);
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
cat(glue::glue("Checking `{.y}`: {ifelse(all(.test), .pass, .fail)}"), sep = "\n")
})
}
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`: PASS
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(...) %>%
rlang::set_names(purrr::map_chr(., \(x) rlang::as_label(rlang::quo_get_expr(x)))) |>
purrr::imap(check_env_arg);
purrr::iwalk(envs, ~{
.names <- attr(.x, "must.have");
if (rlang::is_empty(.names)){
cat("No required values set: exiting ..;", sep = "\n");
return("N/A")
}
.test <- rlang::env_has(.x, .names);
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
cat(glue::glue("Checking `{.y}`: {ifelse(all(.test), .pass, .fail)}"), sep = "\n")
})
}
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`: PASS
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(...) %>%
rlang::set_names(purrr::map_chr(., \(x) rlang::as_label(rlang::quo_get_expr(x)))) |>
purrr::imap(check_env_arg);
purrr::iwalk(envs, ~{
.names <- attr(.x, "must.have");
if (rlang::is_empty(.names)){
cat("No required values set: exiting ..;", sep = "\n");
return("N/A")
}
.test <- rlang::env_has(.x, .names);
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
if (!all(.test)){ cat(.fail, sep = "\n") }
})
}
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`: PASS
# undebug(`%-=%`)
BLAH %-=% c("W", "Y")
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y)
check.env(.GlobalEnv, BLAH, BLEH)
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked.  Use the \code{\link[rlang]{!!}} operator when passing a vector or list.
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env, env_nm = rlang::as_label(rlang::enexpr(env)));
x <- rlang::enexprs(x) |> purrr::compact();
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map(x, as.character) |> unlist()
} else {
attr(env, "must.have") <- purrr::map(x, as.character) |> unlist() |>
c(attr(env, "must.have")) |> unique() |>
purrr::discard(\(x) grepl(paste0("^[-!]", x), x))
}
}
}
BLAH %must.have% !!c("-W", "-Y")
BLAH %must.have% !!c("W", "Y", "Z")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y)
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked.  Use the \code{\link[rlang]{!!}} operator when passing a vector or list.
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env, env_nm = rlang::as_label(rlang::enexpr(env)));
x <- rlang::enexprs(x) |> purrr::compact();
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map(x, as.character) |> unlist()
} else {
.names <- purrr::map(x, as.character) |> unlist();
.not_have <- if (any(grepl("^[-!]", .names))){ grep("^[-!].+", .names, value = TRUE) |> stringi::stri_replace_first_regex("[-!]", "") }
attr(env, "must.have") <- .names[!(grepl("^[-!]", .names) | (.names %in% .not_have))] |> c(attr(env, "must.have")) |> unique()
}
}
}
BLAH %must.have% !!c("-W", "-Y")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y)
BLAH %+=% list(Z = 10)
rlang::env_has(BLAH, "Z") # TRUE
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3))
rlang::env_has(BLAH, c("W", "Y")) # TRUE TRUE
rm(W, Y, Z, envir = BLAH)
BLAH %must.have% !!c("W", "Y", "Z")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`:
# undebug(`%-=%`)
# undebug(`%must.have%`)
BLAH %-=% c("W", "Y")
BLAH %must.have% !!c("-W", "-Y")
debug(`%must.have%`)
BLAH %must.have% !!c("-W", "-Y")
.names
.not_have
.names[!(grepl("^[-!]", .names) | (.names %in% .not_have))]
c(attr(env, "must.have"))
.names[!(grepl("^[-!]", .names) | (.names %in% .not_have))]
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked.  Use the \code{\link[rlang]{!!}} operator when passing a vector or list.
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env, env_nm = rlang::as_label(rlang::enexpr(env)));
x <- rlang::enexprs(x) |> purrr::compact();
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map(x, as.character) |> unlist()
} else {
.names <- purrr::map(x, as.character) |> unlist() |> c(attr(env, "must.have")) |> unique();
.not_have <- if (any(grepl("^[-!]", .names))){ grep("^[-!].+", .names, value = TRUE) |> stringi::stri_replace_first_regex("[-!]", "") }
attr(env, "must.have") <- .names[!(grepl("^[-!]", .names) | (.names %in% .not_have))]
}
}
}
BLAH %must.have% !!c("-W", "-Y")
`%must.have%`(BLAH)
BLAH %+=% list(Z = 10)
rlang::env_has(BLAH, "Z") # TRUE
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3))
rlang::env_has(BLAH, c("W", "Y")) # TRUE TRUE
rm(W, Y, Z, envir = BLAH)
BLAH %must.have% !!c("W", "Y", "Z")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`:
# undebug(`%-=%`)
# undebug(`%must.have%`)
BLAH %-=% c("W", "Y")
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y)
BLAH %must.have% !!c("-W", "-Y")
`%must.have%`(BLAH)
check.env(.GlobalEnv, BLAH, BLEH)
`%must.have%`(BLAH)
library(book.of.workflow)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(book.of.workflow)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
