unit_tests$must_have$test_2 |> eval()
unit_tests$must_have$test_3 |> eval()
unit_tests$must_have$test_4 |> eval()
unit_tests$must_have$test_5 |> eval()
unit_tests$must_have$test_6 |> eval()
check.env(BLAH, BLEH)
#
#
# %+=%, %-=% ----
BLAH %+=% list(Z = 10)
rlang::env_has(BLAH, "Z") # TRUE
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3))
rlang::env_has(BLAH, c("W", "Y")) # TRUE TRUE
rm(W, Y, Z, envir = BLAH)
BLAH %must.have% !!c("W", "Y", "Z")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`: PASS
# undebug(`%-=%`)
BLAH %-=% c("W", "Y")
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y)
check.env(.GlobalEnv, BLAH, BLEH)
library(book.of.workflow)
snippets_toc()
snippets_toc()
#
# pkgdown ----
pkgdown::build_site()
#
# pkgdown ----
pkgdown::build_site(pkg = "pkg")
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
make_test_objs <- rlang::expr({
BLAH <- new.env()
BLEH <- new.env()
rlang::set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
rlang::set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
})
unit_tests <- list()
sapply(dir("pkg/R", full.names = TRUE), source)
library(stringi);
library(parallelly);
library(future);
library(foreach);
library(data.table)
unit_tests$copy_obj <- rlang::exprs(
test_1 = {
copy_obj(A, keep.orig = TRUE);
list(`.GlobalEnv` = rlang::env_has(.GlobalEnv, c("A")));
}
, test_2 = {
copy_obj(B, C, D, keep.orig = TRUE);
list(`.GlobalEnv` = rlang::env_has(.GlobalEnv, c("B", "C", "D")));
}
, test_3 = {
copy_obj(B, C, D, to_env = BLAH, keep.orig = TRUE);
list(BLAH = rlang::env_has(env = BLAH, nms = c("B", "C", "D")));
}
, test_4 = {
copy_obj(B, C, D, from_env = BLAH, to_env = BLEH, keep.orig = TRUE);
list(BLEH = rlang::env_has(env = BLEH, nms = c("B", "C", "D")));
}
, test_5 = {
copy_obj(E, `F`, G, to_env = BLEH, keep.orig = TRUE);
list(BLEH = rlang::env_has(BLEH, c("E", "F", "G")))
}
, test_6 = {
copy_obj(A, B, C, D, E, `F`, G, to_env = c(BLEH, BLAH), keep.orig = TRUE);
list(
BLAH = rlang::env_has(BLAH, c("A", "B", "C", "D", "E", "F", "G"))
, BLEH = rlang::env_has(BLEH, c("A", "B", "C", "D", "E", "F", "G"))
)
}
, test_7 = {
copy_obj(!!!(LETTERS[1:7]), to_env = c(BLEH, BLAH), keep.orig = FALSE);
list(
BLAH = rlang::env_has(BLAH, LETTERS[1:7])
, BLEH = rlang::env_has(BLEH, LETTERS[1:7])
, `.GlobalEnv` = rlang::env_has(.GlobalEnv, c("H", "I", "J"))
)
}
, test_8 = {
copy_obj(`BLAH$alpha` = H, `BLAH$beta` = I, `BLEH$gamma` = J, keep.orig = !TRUE);
list(
BLAH = rlang::env_has(BLAH, c("alpha", "beta")) |> print()
, BLEH = rlang::env_has(BLEH, c("gamma")) |> print()
, `.GlobalEnv` = !rlang::env_has(.GlobalEnv, c("H", "I", "J")) |> print()
)
}
);
make_test_objs |> eval()
purrr::imap(unit_tests$copy_obj[], ~{ message(.y); eval(.x, envir = globalenv()) })
# debug(copy_obj)
copy_obj(EEEE = A, to_env = .GlobalEnv, keep.orig = !FALSE)
copy_obj(DDDD = A, to_env = c(.GlobalEnv, BLAH), keep.orig = FALSE)
copy_obj(zz = EEEE, to_env = c(.GlobalEnv, BLAH), keep.orig = !FALSE)
copy_obj(WHY.WOULD.USE.USE.THIS.AS.AN.OBJECT.NAME = B, to_env = c(BLEH, BLAH), keep.orig = !FALSE)
lifecycle::last_lifecycle_warnings()
View(BLAH)
# ~ %must.have% ----
eval(make_test_objs)
attr(.GlobalEnv, "must.have") <- NULL
`%must.have%`(.GlobalEnv) # NULL
unit_tests$must_have <- rlang::exprs(
test_1 = {
environment() %must.have% A
`%must.have%`(.GlobalEnv) # NULL
copy_obj(A, keep.orig = TRUE);
check.env(.GlobalEnv)
}
, test_2 = {
.GlobalEnv %must.have% !!c("B", "C", "D", `%must.have%`(.GlobalEnv))
`%must.have%`(.GlobalEnv) 	# NULL
copy_obj(B, C, D, keep.orig = TRUE)
check.env(.GlobalEnv)
}
, test_3 = {
BLAH %must.have% !!c("B", "C", "D")
`%must.have%`(BLAH)
copy_obj(B, C, D, to_env = BLAH, keep.orig = TRUE);
check.env(BLAH)
}
, test_4 = {
BLEH %must.have% !!c("B", "C", "D")
`%must.have%`(BLEH)
copy_obj(B, C, D, from_env = BLAH, to_env = BLEH, keep.orig = TRUE);
check.env(BLEH)
}
, test_5 = {
BLEH %must.have% !!c("E", "F", "G")
`%must.have%`(BLEH)
copy_obj(E, `F`, G, to_env = BLEH, keep.orig = TRUE);
check.env(BLEH)
}
, test_6 = {
BLEH %must.have% !!c("A", "B", "C", "D", "E", "F", "G")
`%must.have%`(BLAH)
`%must.have%`(BLEH)
copy_obj(A, B, C, D, E, `F`, G, to_env = c(BLEH, BLAH), keep.orig = TRUE);
check.env(BLAH, BLEH)
}
)
eval(make_test_objs)
unit_tests$must_have$test_1 |> eval()
unit_tests$must_have$test_2 |> eval()
unit_tests$must_have$test_3 |> eval()
unit_tests$must_have$test_4 |> eval()
unit_tests$must_have$test_5 |> eval()
unit_tests$must_have$test_6 |> eval()
check.env(BLAH, BLEH)
#
# %+=%, %-=% ----
BLAH %+=% list(Z = 10)
rlang::env_has(BLAH, "Z") # TRUE
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3))
rlang::env_has(BLAH, c("W", "Y")) # TRUE TRUE
rm(W, Y, Z, envir = BLAH)
BLAH %must.have% !!c("W", "Y", "Z")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
`%must.have%`(BLAH)
purrr::modify_at(`%must.have%`(BLAH), c(1,2,3), \(x) paste0("!", x))
BLAH %must.have% !!!purrr::modify_at(`%must.have%`(BLAH), c(1,2,3), \(x) paste0("!", x))
BLAH %must.have% !!purrr::modify_at(`%must.have%`(BLAH), c(1,2,3), \(x) paste0("!", x))
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
`%must.have%`(BLAH)
purrr::modify_at(`%must.have%`(BLAH), c(1,2,3), \(x) paste0("!", x))
BLAH %must.have% !!purrr::modify_at(`%must.have%`(BLAH), c(1,2,3), \(x) paste0("!", x))
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked.  Use the \code{\link[rlang]{!!}} operator when passing a vector or list.  Start a string with "-" or "!" to remove an existing entry
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env);
x <- rlang::enexprs(x) |> purrr::compact();
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){
return()
} else {
return(attr(env, "must.have"))
}
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map(x, as.character) |>
unlist() |>
purrr::discard(\(x) grepl("^[-!]", x))
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character) |>
c(attr(env, "must.have")) |>
unique() |>
purrr::discard(\(x) grepl("^[-!]", x))
}
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked.  Use the \code{\link[rlang]{!!}} operator when passing a vector or list.  Start a string with "-" or "!" to remove an existing entry
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env);
x <- rlang::enexprs(x) |> as.character() |> purrr::compact();
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){
return()
} else {
return(attr(env, "must.have"))
}
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map(x, as.character) |>
unlist() |>
purrr::discard(\(x) grepl("^[-!]", x))
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character) |>
c(attr(env, "must.have")) |>
unique() |>
purrr::discard(\(x) grepl("^[-!]", x))
}
`%must.have%`(BLAH)
BLAH %must.have% !!purrr::modify_at(`%must.have%`(BLAH), c(1,2,3), \(x) paste0("!", x))
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
rlang::env_has(BLAH, c("W", "Y")) # TRUE TRUE
BLAH %must.have% !!c("W", "Y", "Z")
`%must.have%`(BLAH)
attr(BLAH, "must.have")
`%must.have%`(BLAH)[-c(1,2)]
attr(BLAH, "must.have") <- `%must.have%`(BLAH)[-c(1,2)]
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked.  Use the \code{\link[rlang]{!!}} operator when passing a vector or list.  Start a string with "-" or "!" to remove an existing entry
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env);
x <- rlang::enexprs(x) |> as.character() |> purrr::compact();
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){
return()
} else {
return(attr(env, "must.have"))
}
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map(x, as.character) |>
unlist() |>
purrr::discard(\(x) grepl("^[-!]", x))
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character) |>
c(attr(env, "must.have")) |>
unique() |>
purrr::discard(\(x) grepl("^[-!]", x))
}
purrr::modify_at(`%must.have%`(BLAH), c(1,2,3), \(x) paste0("!", x))
BLAH %must.have% purrr::modify_at(`%must.have%`(BLAH), c(1,2,3), \(x) paste0("!", x))
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
`%must.have%`(BLAH)[-c(1,2)]
attr(BLAH, "must.have") <- c(`%must.have%`(BLAH)[-c(1,2)], "W")
attr(BLAH, "must.have")
BLAH %must.have% !!c("!W", "!Y", "-Z")
attr(BLAH, "must.have")
attr(BLAH, "must.have") <- `%must.have%`(BLAH)[-1]
attr(BLAH, "must.have")
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked.  Use the \code{\link[rlang]{!!}} operator when passing a vector or list.  Start a string with "-" or "!" to remove an existing entry
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env);
x <- purrr::compact(x);
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){
return()
} else {
return(attr(env, "must.have"))
}
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map_chr(x, as.character) |>
unique() |>
purrr::discard(\(i) grepl("^[-!]", i))
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character) |>
c(attr(env, "must.have")) |>
unique() |>
purrr::discard(\(i) grepl("^[-!]", i))
}
BLAH %must.have% !!c("!W", "!Y", "-Z")
BLAH %must.have% c("!W", "!Y", "-Z")
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked. Start a string with "-" or "!" to remove an existing entry
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env);
x <- purrr::compact(x);
if (identical(x, "")){
if (rlang::is_empty(attr(env, "must.have"))){
return()
} else {
return(attr(env, "must.have"))
}
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map_chr(x, as.character) |>
unique() |>
purrr::discard(\(i) grepl("^[-!]", i))
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character) |>
c(attr(env, "must.have")) |>
unique() |>
purrr::discard(\(i) grepl("^[-!]", i))
}
BLAH %must.have% c("!W", "!Y", "-Z")
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
`%must.have%`(BLAH)
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked. Start a string with "-" or "!" to remove an existing entry
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env);
x <- purrr::compact(x);
if (identical(x, "")){
if (rlang::is_empty(attr(env, "must.have"))){
return()
} else {
return(attr(env, "must.have"))
}
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::discard(\(i) grepl("^[-!]", i)) |> unique()
} else {
attr(env, "must.have") <- c(attr(env, "must.have"), x) |> unique() |>
purrr::discard(\(i) grepl("^[-!]", i))
}
BLAH %must.have% c("!W", "!Y", "-Z")
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
`%must.have%`(BLAH)
?setattr
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(..., .named = TRUE) |> purrr::map(check_env_arg);
purrr::iwalk(envs, ~{
.test <- rlang::env_has(.x, attr(.x, "must.have"));
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
cat(glue::glue("Checking `{.y}`: { ifelse(all(.test), .pass, .fail) }"), sep = "\n")
ifelse(all(.test), TRUE, FALSE)
})
}
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If not all objects that \code{env} \code{\link{\%must.have\%}} are present, an error message is produced; a corresponding logical is invisibly returned
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(..., .named = TRUE) |> purrr::map(check_env_arg);
purrr::iwalk(envs, ~{
.test <- rlang::env_has(.x, attr(.x, "must.have"));
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
cat(glue::glue("Checking `{.y}`: { ifelse(all(.test), .pass, .fail) }"), sep = "\n");
invisible(ifelse(all(.test), TRUE, FALSE))
})
}
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked. Start a string with "-" or "!" to remove an existing entry
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
if (!check_env_arg(env)){ return() }
x <- purrr::compact(x);
if (identical(x, "")){
if (rlang::is_empty(attr(env, "must.have"))){
return()
} else {
return(attr(env, "must.have"))
}
} else {
if (rlang::is_empty(attr(env, "must.have"))){
setattr(env, "must.have") <- purrr::discard(\(i) grepl("^[-!]", i)) |> unique()
} else {
attr(env, "must.have") <- c(attr(env, "must.have"), x) |> unique() |>
purrr::discard(\(i) grepl("^[-!]", i))
}
`%must.have%`(BLAH)
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked. Start a string with "-" or "!" to remove an existing entry
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
if (magrittr::not(check_env_arg(env))){ return() }
x <- purrr::compact(x);
if (identical(x, "")){
if (rlang::is_empty(attr(env, "must.have"))){
return()
} else {
return(attr(env, "must.have"))
}
} else {
if (rlang::is_empty(attr(env, "must.have"))){
setattr(env, "must.have") <- purrr::discard(\(i) grepl("^[-!]", i)) |> unique()
} else {
attr(env, "must.have") <- c(attr(env, "must.have"), x) |> unique() |>
purrr::discard(\(i) grepl("^[-!]", i))
}
`%must.have%`(BLAH)
check_env_arg(BLAH)
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked. Start a string with "-" or "!" to remove an existing entry
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env);
x <- purrr::compact(x);
if (identical(x, "")){
if (rlang::is_empty(attr(env, "must.have"))){
return()
} else {
return(attr(env, "must.have"))
}
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::discard(\(i) grepl("^[-!]", i)) |> unique()
} else {
attr(env, "must.have") <- c(attr(env, "must.have"), x) |> unique() |> purrr::discard(\(i) grepl("^[-!]", i))
}
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
BLAH %must.have% c("!W", "!Y", "-Z")
`%must.have%`(BLAH)
debug(`%must.have%`)
BLAH %must.have% c("!W", "!Y", "-Z")
c(attr(env, "must.have"), x) |> unique()
c(attr(env, "must.have"), x) |> purrr::discard(\(i) grepl("^[-!]", i))|> unique()
