stats::na.omit()
})
}
});
if (chatty){ print(library.cfg) }
new.libs = purrr::keep(names(library.cfg), ~!.x %in% rownames(utils::installed.packages()));
if (!rlang::is_empty(new.libs)){
if (is.list(autoinstall)){
rlang::inject(utils::install.packages(pkgs = new.libs, !!!autoinstall))
} else if (is.logical(autoinstall)==autoinstall){ utils::install.packages(pkgs = new.libs) }
}
invisible(
library.cfg[
# Don't try to load libraries already loaded and attached via indexing against `library.cfg`
purrr::map_lgl(names(library.cfg), ~{ magrittr::not(any(grepl(.x, search()))) })
] |> purrr::imap(~tryCatch(expr = { do.call(
what = "library"
, args = append(
.x[c(length(.x$include) > 0, length(.x[[2]]) > 0)] # <- User syntax error can lead to both being true, so let the call to 'library()' error out
, list(package = .y, attach.required = TRUE, quietly = !chatty, warn.conflicts = FALSE)
))
}, error = function(e){ message(e) }))
)
}
debug(load_unloaded)
load_unloaded("cachem{+cache_disk}")
View(library.cfg)
# ::::: ENVIRONMENT PROCESSING
load_unloaded <- function(..., libs = NULL, delim = "[,|; ]", autoinstall = FALSE, chatty = FALSE) {
#' Load Unloaded Packages
#'
#' \code{load_unloaded}checks the packages provided in \code{libs} against a call to \code{\link[base]{search}} and only makes a call to \code{\link[base]{library}} for unloaded (and attached) libraries.
#'
#' Library names can be declared in a single, delimited string (e.g., \code{"name0 name1, name2|name3"}) or as a vector of strings (e.g. \code{c("name0", "name1", "name2")}).
#' Inclusions and exclusions can be declared using the following template:\cr  \code{"library_name{+name0+name1+...}"} for inclusions and \code{"library_name{-name0-name1-...}"}.  Since inclusions and exclusions cannot be used in the same call to \code{\link[base]{library}}(), trying to do so with this function will result in an error.
#'
#' @param ... \code{\link[rlang]{dots_list}} A vector of packages to load given as characters.  Delimited strings are allowed: \emph{DO NOT use \code{+} or \code{-}}.
#' @param libs (string[]) A vector of packages to load given as characters or symbols.  Delimited strings are allowed: \emph{DO NOT use \code{+} or \code{-}}.
#' @param delim  (string | "[, ]") A regular expression delimiter pattern that operates on `str`: \emph{DO NOT use glyphs \code{+} or \code{-}}.
#' @param autoinstall
#' \itemize{
#'	\item{\code{FALSE} (default): A notification message is provided if \code{chatty} is \code{TRUE}; otherwise, no message is sent}
#'	\item{\code{TRUE}: If a library isn't installed, it will be using the default library installation path}
#'	\item{\code{list()}: Assumes \code{TRUE} and should be a list of arguments (excluding \code{pkgs}) to send to \code{\link[utils]{install.packages}}}
#'	}
#' @param chatty (logical | \code{FALSE}) Sets the \code{quietly} argument in the call to \code{\link[base]{library}}()
#'
#' @return See \code{\link[base]{library}}
#'
#' @family Environment Processing
#'
#' @export
libs <- c(as.character(rlang::enexprs(...)), libs);
if (chatty){ cat(libs, sep = "\n") }
.tmp_str <- stringi::stri_split_regex(str = libs, pattern = delim, simplify = TRUE, omit_empty = TRUE) |> unlist();
.tmp_str <- rlang::set_names(
.tmp_str
, stringi::stri_replace_all_regex(.tmp_str, pattern = "([{].*.[}])?", replacement = "", simplify = TRUE) |> unlist()
);
library.cfg <- purrr::map(.tmp_str, ~{
ns_objs <- stringi::stri_split_regex(.x, pattern = "[{}]", omit_empty = TRUE, simplify = TRUE) |> unlist() |> magrittr::extract(-1)
if (rlang::is_empty(ns_objs)){
rlang::set_names(list(NULL, NULL), c("include.only", "exclude"))
} else {
purrr::map(
.x = rlang::set_names(c("[+]", "[-]"), c("include.only", "exclude"))
, .f = ~{ stringi::stri_extract_all_regex(ns_objs, pattern = paste0(.x, "[a-zA-Z0-9._]+"), simplify = TRUE) |>
stats::na.omit() |>
stringi::stri_replace_all_regex(pattern = "[+-]", replacement = "", vectorize_all = FALSE)
})
}
});
if (chatty){ print(library.cfg) }
new.libs = purrr::keep(names(library.cfg), ~!.x %in% rownames(utils::installed.packages()));
if (!rlang::is_empty(new.libs)){
if (is.list(autoinstall)){
rlang::inject(utils::install.packages(pkgs = new.libs, !!!autoinstall))
} else if (is.logical(autoinstall)==autoinstall){ utils::install.packages(pkgs = new.libs) }
}
invisible(
library.cfg[
# Don't try to load libraries already loaded and attached via indexing against `library.cfg`
purrr::map_lgl(names(library.cfg), ~{ magrittr::not(any(grepl(.x, search()))) })
] |> purrr::imap(~tryCatch(expr = { do.call(
what = "library"
, args = append(
.x[c(length(.x$include) > 0, length(.x[[2]]) > 0)] # <- User syntax error can lead to both being true, so let the call to 'library()' error out
, list(package = .y, attach.required = TRUE, quietly = !chatty, warn.conflicts = FALSE)
))
}, error = function(e){ message(e) }))
)
}
debug(load_unloaded)
load_unloaded("cachem{+cache_disk}")
View(library.cfg)
"packageg:cachem" %in% search()
"packageg:cachem" %in% print(search())
"package:cachem" %in% print(search())
ls(as.environment("package:cachem"))
identical("cache_disk", ls(as.environment("package:cachem")))
undebug(load_unloaded)
# debug(load_unloaded)
load_unloaded("furrr{-future_imap}|arules")
paste0("package:", c("furrr", "arules")) %in% print(search())
"future_imap" %in% ls(as.environment("package:furrr"))
# library(book.of.workflow)
sapply(dir("pkg/R", full.names = TRUE), source)
# library(magick)
# library(jsonlite)
# library(sodium)
# magick::image_read("book-305126_1280.png") %>% serialize(connection = NULL) %>% base64enc::base64encode() %>% writeClipboard()
make_test_objs <- rlang::expr({
BLAH <- new.env()
BLEH <- new.env()
set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
})
# Environment must also have ...
`%+must.have%` <- function(env, x){
#' Must Have in Addition
#'
#' \code{\%\+must.have\%} adds additional object names as "must haves" for the given environment
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have in addition to existing required objects, invisibly
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
if (rlang::is_empty(attr(env, "must.have"))){
env %must.have% x
} else {
attr(env, "must.have") <- append(attr(env, "must.have"), rlang::as_quosures(x = rlang::enexprs(x, .named = TRUE), env = env, named = TRUE));
}
# Environment must have ...
`%must.have%` <- function(env, x){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
attr(env, "must.have") <- rlang::as_quosures(x = rlang::enexprs(x, .named = TRUE), env = env, named = TRUE);
}
# Check if environment has what is should
check.env <- function(env){
#' Environment Integrity Check
#'
#' \code{\%check\%} checks the environment for required objects
#'
#' @param env (object | string) An environment or name of an environment
#' @param x (string[]) The names of the objects that \code{env} must have
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env)
logi.vec <- !rlang::env_has(env, attr(env, "must.have"));
if (any(stats::na.omit(logi.vec))){ stop(glue::glue("Missing objects: {paste(x[logi.vec], collapse = ", ")}")) }
}
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Environmental Integrity
#' @export
envs <- purrr::map(rlang::enquos(..., .named = TRUE), check_env_arg);
purrr::iwalk(envs, ~{
message(glue::glue("Checking `{.y}`"))
stopifnot(rlang::env_has(.x, attr(.x, "must.have")));
})
}
# ~ %must.have%, %+must.have% ----
environment() %must.have%
unit_tests <- list(
copy_obj = rlang::exprs(
test_1 = {
copy_obj(A, keep.orig = TRUE);
list(`.GlobalEnv` = rlang::env_has(.GlobalEnv, c("A")));
}
, test_2 = {
copy_obj(B, C, D, keep.orig = TRUE);
list(`.GlobalEnv` = rlang::env_has(.GlobalEnv, c("B", "C", "D")));
}
, test_3 = {
copy_obj(B, C, D, to_env = BLAH, keep.orig = TRUE);
list(BLAH = rlang::env_has(env = BLAH, nms = c("B", "C", "D")));
}
, test_4 = {
copy_obj(B, C, D, from_env = BLAH, to_env = BLEH, keep.orig = TRUE);
list(BLEH = rlang::env_has(env = BLEH, nms = c("B", "C", "D")));
}
, test_5 = {
copy_obj(E, `F`, G, to_env = BLEH, keep.orig = TRUE);
list(BLEH = rlang::env_has(BLEH, c("E", "F", "G")))
}
, test_6 = {
copy_obj(A, B, C, D, E, `F`, G, to_env = c(BLEH, BLAH), keep.orig = TRUE);
list(
BLAH = rlang::env_has(BLAH, c("A", "B", "C", "D", "E", "F", "G"))
, BLEH = rlang::env_has(BLEH, c("A", "B", "C", "D", "E", "F", "G"))
)
}
, test_7 = {
copy_obj(!!!(LETTERS[1:7]), to_env = c(BLEH, BLAH), keep.orig = FALSE);
list(
BLAH = rlang::env_has(BLAH, LETTERS[1:7])
, BLEH = rlang::env_has(BLEH, LETTERS[1:7])
, `.GlobalEnv` = rlang::env_has(.GlobalEnv, c("H", "I", "J"))
)
}
, test_8 = {
copy_obj(`BLAH$alpha` = H, `BLAH$beta` = I, `BLEH$gamma` = J, keep.orig = !TRUE);
list(
BLAH = rlang::env_has(BLAH, c("alpha", "beta")) |> print()
, BLEH = rlang::env_has(BLEH, c("gamma")) |> print()
, `.GlobalEnv` = !rlang::env_has(.GlobalEnv, c("H", "I", "J")) |> print()
)
}
) |>
setattr("init", make_test_objs)
);
# ~ %must.have%, %+must.have% ----
`%must.have%`(environment() )
# ~ %must.have%, %+must.have% ----
environment() %+must.have% NULL
# Environment must have ...
`%must.have%` <- function(env, x = NULL){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
if (rlang::is_empty(x)){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
}
attr(env, "must.have") <- purrr::map_chr(x, as.character)
}
# ~ %must.have%, %+must.have% ----
environment() %+must.have%
`%must.have%`(environment())
# ~ %must.have%, %+must.have% ----
environment() %+must.have%
`%must.have%`(environment())
# Environment must have ...
`%must.have%` <- function(env, x = NULL){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
if (rlang::is_empty(x)){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
}
attr(env, "must.have") <- purrr::map_chr(rlang::enexprs(x), as.character)
}
environment() %+must.have% A
`%must.have%`(environment())
attr(environment(), "must.have") <- NULL
attr(.GlobalEnv, "must.have") <- NULL
# ~ %must.have%, %+must.have% ----
`%must.have%`(environment())
environment() %+must.have% A
# Environment must have ...
`%must.have%` <- function(env, x = NULL){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
x <- rlang::enexprs(x);
env <- check_env_arg(env);
if (rlang::is_empty(x)){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
}
attr(env, "must.have") <- purrr::map_chr(x, as.character)
}
environment() %+must.have% A
`%must.have%`(environment())
# ~ %must.have%, %+must.have% ----
`%must.have%`(.GlobalEnv)
# Environment must have ...
`%must.have%` <- function(env, x = NULL){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
if (rlang::is_empty(x)){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
x <- rlang::enexprs(x);
attr(env, "must.have") <- purrr::map_chr(x, as.character)
}
# ~ %must.have%, %+must.have% ----
`%must.have%`(.GlobalEnv)
environment() %+must.have% A
`%must.have%`(.GlobalEnv)
rm(`%+must.have`)
rm(`%+must.have%`)
environment() %must.have% A
`%must.have%` <- function(env, x = NULL){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
if (rlang::is_empty(x)){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
x <- rlang::enexprs(x);
attr(env, "must.have") <- purrr::map_chr(x, as.character)
}
environment() %must.have% A
# Environment must have ...
`%must.have%` <- function(env, x = NULL){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
x <- rlang::enexprs(x);
if (rlang::is_empty(x)){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character)
}
# Environment must have ...
`%must.have%` <- function(env, x = NULL){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
x <- rlang::enexprs(x);
if (rlang::is_empty(x)){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character)
}
# ~ %must.have%, %+must.have% ----
`%must.have%`(.GlobalEnv)
# Environment must have ...
`%must.have%` <- function(env, x = NULL){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
x <- rlang::enexprs(x) |> purrr::compact();
if (rlang::is_empty(x)){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character)
}
# ~ %must.have%, %+must.have% ----
`%must.have%`(.GlobalEnv)
environment() %must.have% A
`%must.have%`(.GlobalEnv)
`%must.have%`(environment())
.GlobalEnv %must.have% c("B", "C", "D", !!`%must.have%`(.GlobalEnv))
.GlobalEnv %must.have% c("B", "C", "D", `%must.have%`(.GlobalEnv))
`%must.have%`(.GlobalEnv)
c("B", "C", "D", `%must.have%`(.GlobalEnv))
# Environment must have ...
`%must.have%` <- function(env, x = NULL){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
x <- rlang::enexprs(x) |> magrittr::extract(1) |> purrr::compact();
if (rlang::is_empty(x)){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character)
}
.GlobalEnv %must.have% c("B", "C", "D", `%must.have%`(.GlobalEnv))
debug(`%must.have%`)
.GlobalEnv %must.have% c("B", "C", "D", `%must.have%`(.GlobalEnv))
x[[1]]
# Environment must have ...
`%must.have%` <- function(env, x = NULL){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
x <- rlang::ensyms(x) |> purrr::compact();
if (rlang::is_empty(x)){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character)
}
# ~ %must.have%, %+must.have% ----
`%must.have%`(.GlobalEnv)
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
x <- rlang::ensyms(x) |> purrr::compact();
if (rlang::is_empty(x)){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character)
}
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{\%check\%}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A string vector of the names that \code{env} must have when checked
#'
#' @return The names of the objects that \code{env} must have
#' @family Environmental Integrity
#' @export
env <- check_env_arg(env);
x <- rlang::ensyms(x) |> purrr::compact();
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
attr(env, "must.have") <- purrr::map_chr(x, as.character)
}
# ~ %must.have%, %+must.have% ----
`%must.have%`(.GlobalEnv)
environment() %must.have% A
`%must.have%`(.GlobalEnv)
`%must.have%`(environment())
.GlobalEnv %must.have% c("B", "C", "D", `%must.have%`(.GlobalEnv))
.GlobalEnv %must.have% c("B", "C", "D", !!!`%must.have%`(.GlobalEnv))
