})
make_test_objs |> eval()
unit_tests <- list()
unit_tests$copy_obj <- "unit_tests/copy_obj_test.R"
unit_tests$must_have <-"unit_tests/must_have_test.R"
unit_tests$snippets <-"unit_tests/snippets_test.R"
unit_tests$load_unloaded <-"unit_tests/load_unloaded_test.R"
# ~ load_unloaded() :: Run from fresh session to ensure libraries are not loaded ----
(\(x, y = names(x)){ message(y); source(x[[1]]) })(unit_tests$load_unloaded);
"future_imap" %in% ls(as.environment("package:furrr")) == FALSE|> print()
("future_imap" %in% ls(as.environment("package:furrr")) == FALSE)
# library(magick)
# library(jsonlite)
# library(sodium)
# magick::image_read("book-305126_1280.png") %>% serialize(connection = NULL) %>% base64enc::base64encode() %>% writeClipboard()
sapply(dir("pkg/R", full.names = TRUE), source)
make_test_objs <- rlang::expr({
BLAH <- new.env()
BLEH <- new.env()
rlang::set_names(letters[1:10], LETTERS[1:10]) |> as.list() |> list2env(envir = globalenv())
rlang::set_names(letters[11:20], LETTERS[11:20]) |> as.list() |> list2env(envir = BLEH)
.pattern <- "^[A-Z]$"
})
make_test_objs |> eval()
unit_tests <- list()
unit_tests$copy_obj <- "unit_tests/copy_obj_test.R"
unit_tests$must_have <-"unit_tests/must_have_test.R"
unit_tests$snippets <-"unit_tests/snippets_test.R"
unit_tests$load_unloaded <-"unit_tests/load_unloaded_test.R"
# ~ load_unloaded() :: Run from fresh session to ensure libraries are not loaded ----
(\(x, y = names(x)){ message(y); source(x[[1]]) })(unit_tests$load_unloaded);
#
#
# %+=%, %-=% ----
BLAH %+=% list(Z = 10)
source("D:/Imperial Git Repos/book.of.workflow/pkg/R/2_environment_integrity.R")
#
#
# %+=%, %-=% ----
BLAH %+=% list(Z = 10)
rlang::env_has(BLAH, "Z") # TRUE
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3))
rlang::env_has(BLAH, c("W", "Y")) # TRUE TRUE
rm(W, Y, Z, envir = BLAH)
BLAH %must.have% !!c("W", "Y", "Z")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`: PASS
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(...) |>
rlang::set_names(purrr::map_chr(\(x) rlang::as_label(rlang::quo_get_expr(x)))) |>
purrr::map(check_env_arg);
purrr::iwalk(envs, ~{
.names <- attr(.x, "must.have");
if (rlang::is_empty(.names)){
cat("No required values set: exiting ..;", sep = "\n");
return("N/A")
}
.test <- rlang::env_has(.x, .names);
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
cat(glue::glue("Checking `{.y}`: {ifelse(all(.test), .pass, .fail)}"), sep = "\n")
})
}
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`: PASS
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(...) %>%
rlang::set_names(purrr::map_chr(., \(x) rlang::as_label(rlang::quo_get_expr(x)))) |>
purrr::map(check_env_arg);
purrr::iwalk(envs, ~{
.names <- attr(.x, "must.have");
if (rlang::is_empty(.names)){
cat("No required values set: exiting ..;", sep = "\n");
return("N/A")
}
.test <- rlang::env_has(.x, .names);
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
cat(glue::glue("Checking `{.y}`: {ifelse(all(.test), .pass, .fail)}"), sep = "\n")
})
}
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`: PASS
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(...) %>%
rlang::set_names(purrr::map_chr(., \(x) rlang::as_label(rlang::quo_get_expr(x)))) |>
purrr::imap(check_env_arg);
purrr::iwalk(envs, ~{
.names <- attr(.x, "must.have");
if (rlang::is_empty(.names)){
cat("No required values set: exiting ..;", sep = "\n");
return("N/A")
}
.test <- rlang::env_has(.x, .names);
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
cat(glue::glue("Checking `{.y}`: {ifelse(all(.test), .pass, .fail)}"), sep = "\n")
})
}
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`: PASS
# Check if environment has what is should
check.env <- function(...){
#' Environment Integrity Check
#'
#' \code{check.env} checks one or more environments for required objects
#'
#' @param ... One or more environments to check
#'
#' @return If all objects that \code{env} \code{\link{\%must.have\%}} are present, nothing is returned; otherwise, an error message is returned.
#' @family Chapter 2 - Environment Integrity
#' @export
envs <- rlang::enquos(...) %>%
rlang::set_names(purrr::map_chr(., \(x) rlang::as_label(rlang::quo_get_expr(x)))) |>
purrr::imap(check_env_arg);
purrr::iwalk(envs, ~{
.names <- attr(.x, "must.have");
if (rlang::is_empty(.names)){
cat("No required values set: exiting ..;", sep = "\n");
return("N/A")
}
.test <- rlang::env_has(.x, .names);
.pass <- "PASS"
.fail <- paste0("FAIL (missing ", paste(names(.test[!.test]) |> trimws(), collapse = ", "), ")");
if (!all(.test)){ cat(.fail, sep = "\n") }
})
}
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`: PASS
# undebug(`%-=%`)
BLAH %-=% c("W", "Y")
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y)
check.env(.GlobalEnv, BLAH, BLEH)
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked.  Use the \code{\link[rlang]{!!}} operator when passing a vector or list.
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env, env_nm = rlang::as_label(rlang::enexpr(env)));
x <- rlang::enexprs(x) |> purrr::compact();
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map(x, as.character) |> unlist()
} else {
attr(env, "must.have") <- purrr::map(x, as.character) |> unlist() |>
c(attr(env, "must.have")) |> unique() |>
purrr::discard(\(x) grepl(paste0("^[-!]", x), x))
}
}
}
BLAH %must.have% !!c("-W", "-Y")
BLAH %must.have% !!c("W", "Y", "Z")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y)
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked.  Use the \code{\link[rlang]{!!}} operator when passing a vector or list.
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env, env_nm = rlang::as_label(rlang::enexpr(env)));
x <- rlang::enexprs(x) |> purrr::compact();
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map(x, as.character) |> unlist()
} else {
.names <- purrr::map(x, as.character) |> unlist();
.not_have <- if (any(grepl("^[-!]", .names))){ grep("^[-!].+", .names, value = TRUE) |> stringi::stri_replace_first_regex("[-!]", "") }
attr(env, "must.have") <- .names[!(grepl("^[-!]", .names) | (.names %in% .not_have))] |> c(attr(env, "must.have")) |> unique()
}
}
}
BLAH %must.have% !!c("-W", "-Y")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y)
BLAH %+=% list(Z = 10)
rlang::env_has(BLAH, "Z") # TRUE
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3))
rlang::env_has(BLAH, c("W", "Y")) # TRUE TRUE
rm(W, Y, Z, envir = BLAH)
BLAH %must.have% !!c("W", "Y", "Z")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`:
# undebug(`%-=%`)
# undebug(`%must.have%`)
BLAH %-=% c("W", "Y")
BLAH %must.have% !!c("-W", "-Y")
debug(`%must.have%`)
BLAH %must.have% !!c("-W", "-Y")
.names
.not_have
.names[!(grepl("^[-!]", .names) | (.names %in% .not_have))]
c(attr(env, "must.have"))
.names[!(grepl("^[-!]", .names) | (.names %in% .not_have))]
# Environment must have ...
`%must.have%` <- function(env, x = ""){
#' Must Have
#'
#' \code{\%must.have\%} sets an attribute in the environment given by \code{env} with the name(s) of the object(s) that the environment must have.  Verification is done via \code{\link{check.env}}.
#'
#' @param env (object) An environment or name of an environment
#' @param x (string[]) A vector or strings containing the object names that \code{env} must have when checked.  Use the \code{\link[rlang]{!!}} operator when passing a vector or list.
#'
#' @return The names of the objects that \code{env} must have
#' @family Chapter 2 - Environment Integrity
#' @export
env <- check_env_arg(env, env_nm = rlang::as_label(rlang::enexpr(env)));
x <- rlang::enexprs(x) |> purrr::compact();
if (x == ""){
if (rlang::is_empty(attr(env, "must.have"))){ return() } else { return(attr(env, "must.have")) }
} else {
if (rlang::is_empty(attr(env, "must.have"))){
attr(env, "must.have") <- purrr::map(x, as.character) |> unlist()
} else {
.names <- purrr::map(x, as.character) |> unlist() |> c(attr(env, "must.have")) |> unique();
.not_have <- if (any(grepl("^[-!]", .names))){ grep("^[-!].+", .names, value = TRUE) |> stringi::stri_replace_first_regex("[-!]", "") }
attr(env, "must.have") <- .names[!(grepl("^[-!]", .names) | (.names %in% .not_have))]
}
}
}
BLAH %must.have% !!c("-W", "-Y")
`%must.have%`(BLAH)
BLAH %+=% list(Z = 10)
rlang::env_has(BLAH, "Z") # TRUE
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3))
rlang::env_has(BLAH, c("W", "Y")) # TRUE TRUE
rm(W, Y, Z, envir = BLAH)
BLAH %must.have% !!c("W", "Y", "Z")
`%must.have%`(BLAH)
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y, Z)
BLAH %+=% list(W = 30, Y = list(a = 1, b = 3), Z = 10)
check.env(BLAH) # Checking `BLAH`:
# undebug(`%-=%`)
# undebug(`%must.have%`)
BLAH %-=% c("W", "Y")
check.env(BLAH) # Checking `BLAH`: FAIL: (missing W, Y)
BLAH %must.have% !!c("-W", "-Y")
`%must.have%`(BLAH)
check.env(.GlobalEnv, BLAH, BLEH)
`%must.have%`(BLAH)
library(book.of.workflow)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(book.of.workflow)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
pkg_desc <- desc::desc(file = "pkg/DESCRIPTION")
pkg_name <- pkg_desc$get_field("Package")
pkg_title <- pkg_desc$get_field("Title")
pkg_file <- glue::glue("pkg/R/{pkg_name}.R")
toc_file <- "pkg/README.md"
pkg_title
pkg_name
pkg_doc_prep <- dir("pkg/R", pattern = "R$", recursive = TRUE, full.names = TRUE) |>
(\(x){ i <- which(grepl("miscell|other", x)); c(x[-i], x[i]) })() |>
purrr::discard(\(x) grepl(pkg_name, x)) |>
purrr::map(\(x){
list(path = x, title = { stringi::stri_replace_all_regex(x, c("pkg/R/", "[.]R$", "[_]"), c("", "", " "), vectorise_all = FALSE) |>
stringi::stri_trans_totitle() })
})
pkg_template <- c("#' \\itemize{", "%s", "#' }") |> paste(collapse = "\n")
pkg_doc_content <- c()
toc_content <- c()
# Populate content
pkg_doc_prep |> purrr::iwalk(\(x, y){
env <- new.env();
source(x$path, local = env)
pkg_doc_content <<- pkg_doc_content |>
c(paste(
glue::glue("#' @section Chapter {y} - {x$title}: ")
, sprintf("#' \\item{\\code{\\link{%s}}}", ls(env)) |>
stringi::stri_replace_all_fixed("%", "\\%", vectorise_all = TRUE) |>
paste(collapse = "\n") |>
sprintf(fmt = pkg_template)
, sep = "\n"
)) |> unique()
toc_content <<- toc_content |>
c(paste(
glue::glue("## Chapter {y} - {x$title}\n\n")
, sprintf("- %s", ls(env)) |> paste(collapse = "\n")
, sep = "\n"
)) |> unique()
})
#
pkg_doc_header <- { paste(
glue::glue("#' @title {pkg_title}")
, "#"
, "#' @description"
, glue::glue("#' The following functional chapters are covered in \\code{{pkg_name}}:\\cr")
, sep = "\n"
)}
#
toc_header <- { paste(
glue::glue("# ![book](book_small.png) {pkg_title}\n\n")
, glue::glue("The following functional families are covered in {pkg_name}:")
, sep = "\n"
)}
#
pkg_doc_footer <- { paste(
"#'"
, "#' @importFrom magrittr %>% %T>% %<>% %$% freduce not"
, "#' @importFrom data.table %between% %ilike% %like% rbindlist last setattr"
, "#' @importFrom stringi %s+%"
, "#' @importFrom utils askYesNo installed.packages"
, glue::glue("#' @name {pkg_name}")
, "NULL"
, sep = "\n"
)}
pkg_doc_content
toc_content
# Populate content
pkg_doc_prep |> purrr::iwalk(\(x, y){
env <- new.env();
source(x$path, local = env)
pkg_doc_content <<- pkg_doc_content |>
c(paste(
glue::glue("#' @section Chapter {y} - {x$title}: ")
, sprintf("#' \\item{\\code{\\link{%s}}}", ls(env)) |>
stringi::stri_replace_all_fixed("%", "\\%", vectorise_all = TRUE) |>
paste(collapse = "\n") |>
sprintf(fmt = pkg_template)
, sep = "\n"
)) |> unique()
toc_content <<- toc_content |>
c(paste(
glue::glue("## Chapter {y} - {x$title}\n\n")
, sprintf("- %s", ls(env)) |> paste(collapse = "\n")
, sep = "\n"
)) |> unique()
})
pkg_doc_content
toc_content
pkg_template <- c("#' \\itemize{", "%s", "#' }") |> paste(collapse = "\n")
pkg_doc_content <- c()
toc_content <- c()
pkg_doc_prep
pkg_doc_prep <- dir("pkg/R", pattern = "R$", recursive = TRUE, full.names = TRUE) |>
(\(x){ i <- which(grepl("miscell|other", x)); c(x[-i], x[i]) })() |>
purrr::discard(\(x) grepl(pkg_name, x)) |>
purrr::map(\(x){
list(path = x, title = { stringi::stri_replace_all_regex(x, c("pkg/R/", "[.]R$", "[_]"), c("", "", " "), vectorise_all = FALSE) |>
stringi::stri_trans_totitle() })
})
pkg_doc_prep
dir("pkg/R", pattern = "R$", recursive = TRUE, full.names = TRUE)
#
# Generation ----
pkg_doc_prep <- dir("pkg/R", pattern = "R$", recursive = TRUE, full.names = TRUE) |>
(\(x){
i <- which(grepl("miscell|other", x));
if (rlang::is_empty(i)){ x } else { c(x[-i], x[i]) }
})() |>
purrr::discard(\(x) grepl(pkg_name, x)) |>
purrr::map(\(x){
list(path = x, title = { stringi::stri_replace_all_regex(x, c("pkg/R/", "[.]R$", "[_]"), c("", "", " "), vectorise_all = FALSE) |>
stringi::stri_trans_totitle()
})
})
pkg_doc_prep
#
pkg_template <- c("#' \\itemize{", "%s", "#' }") |> paste(collapse = "\n")
pkg_doc_content <- c()
toc_content <- c()
# Populate content
pkg_doc_prep |> purrr::iwalk(\(x, y){
env <- new.env();
source(x$path, local = env)
pkg_doc_content <<- pkg_doc_content |>
c(paste(
glue::glue("#' @section Chapter {y} - {x$title}: ")
, sprintf("#' \\item{\\code{\\link{%s}}}", ls(env)) |>
stringi::stri_replace_all_fixed("%", "\\%", vectorise_all = TRUE) |>
paste(collapse = "\n") |>
sprintf(fmt = pkg_template)
, sep = "\n"
)) |> unique()
toc_content <<- toc_content |>
c(paste(
glue::glue("## Chapter {y} - {x$title}\n\n")
, sprintf("- %s", ls(env)) |> paste(collapse = "\n")
, sep = "\n"
)) |> unique()
})
#
pkg_doc_header <- { paste(
glue::glue("#' @title {pkg_title}")
, "#"
, "#' @description"
, glue::glue("#' The following functional chapters are covered in \\code{{pkg_name}}:\\cr")
, sep = "\n"
)}
toc_header <- { paste(
glue::glue("# ![book](book_small.png) {pkg_title}\n\n")
, glue::glue("The following functional families are covered in {pkg_name}:")
, sep = "\n"
)}
#
pkg_doc_footer <- { paste(
"#'"
, "#' @importFrom magrittr %>% %T>% %<>% %$% freduce not"
, "#' @importFrom data.table %between% %ilike% %like% rbindlist last setattr"
, "#' @importFrom stringi %s+%"
, "#' @importFrom utils askYesNo installed.packages"
, glue::glue("#' @name {pkg_name}")
, "NULL"
, sep = "\n"
)}
pkg_doc_header
pkg_doc_header <- { paste(
glue::glue("#' @title {pkg_title}")
, "#"
, "#' @description"
, glue::glue("#' The following functional chapters are covered in \\code{{{pkg_name}}}:\\cr")
, sep = "\n"
)}
pkg_doc_header
pkg_doc_header <- { paste(
glue::glue("#' @title {pkg_title}")
, "#"
, "#' @description"
, glue::glue("#' The following functional chapters are covered in \\code{{{pkg_name}}}:\\cr")
, sep = "\n"
)}
#
toc_header <- { paste(
glue::glue("# ![book](book_small.png) {pkg_title}\n\n")
, glue::glue("The following functional families are covered in {pkg_name}:")
, sep = "\n"
)}
#
pkg_doc_footer <- { paste(
"#'"
, "#' @importFrom magrittr %>% %T>% %<>% %$% freduce not"
, "#' @importFrom data.table %between% %ilike% %like% rbindlist last setattr"
, "#' @importFrom stringi %s+%"
, "#' @importFrom utils askYesNo installed.packages"
, glue::glue("#' @name {pkg_name}")
, "NULL"
, sep = "\n"
)}
#
# Output ----
unlink(pkg_file)
unlink(toc_file)
cat(pkg_doc_header, pkg_doc_content, pkg_doc_footer, sep = "\n#'\n", file = pkg_file)
cat(toc_header, toc_content, sep = "\n\n", file = toc_file, append = FALSE)
#
# Build Site ----
# usethis::use_pkgdown()
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(book.of.workflow)
#
# Build Site ----
# usethis::use_pkgdown()
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(book.of.workflow)
#
# Build Site ----
# usethis::use_pkgdown()
pkgdown::build_site(pkg = "pkg", lazy = TRUE, override = list(destination = "../docs"))
library(book.of.workflow)
pkgdown::build_site(pkg = "pkg", override = list(destination = "../docs"))
library(book.of.workflow)
